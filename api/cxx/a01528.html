<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vortex Lite ISO C++ API Reference Guide: ISO C++ V2 Migration Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="PROJECT_LOGO_Lite.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vortex Lite ISO C++ API Reference Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('a01528.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">ISO C++ V2 Migration Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>As of Vortex Lite version 2.0 the only supported ISO C++ version is V2. Most code written for ISO C++ V1 will still compile and run but there may be some minor changes required. As well as this, ISO C++ V2 introduces a number of improvements over V1 which are detailed in the following document.</p>
<h1><a class="anchor" id="migrationguide_rationale"></a>
Rationale</h1>
<p>While most things haven't changed between ISO C++ V1 and V2 regarding the API, there were a few issues with ISO C++ V1 that needed to be addressed.</p>
<ul>
<li>The first iteration of the ISO C++ Specification contains a few issues.<ul>
<li>ISO C++ V2 has been created to address these issues and as an advance of the new ISO C++ Specification that will be released.</li>
<li><b>An application that uses ISO C++ V2 will be more future proof.</b></li>
</ul>
</li>
<li>The ISO C++ V1 API is build on top of the Classic C++ API.<ul>
<li>To improve performance and reduce maintenance costs, it was decided to remove the dependency of the Classic C++ API and thus remove an extra layer within the implementation.</li>
<li><b>An application that uses ISO C++ V2 will have increased performance and a lower footprint.</b></li>
</ul>
</li>
<li>The ISO C++ V1 API is missing a few features.<ul>
<li>The features that are present in V2 but not in V1 are mainly (but not limited to):<ul>
<li>Most listeners, like PublisherListener and DomainParticipantListener.</li>
<li>Google protocol buffers support.</li>
</ul>
</li>
<li><b>An application that uses ISO C++ V2 will have a more complete feature set.</b></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="migrationguide_api_changes"></a>
API Changes</h1>
<ul>
<li>Down-casting within an entity class hierarchy has improved.<ul>
<li>Up and down-casting can be done by constructors and assignment operators.</li>
<li>An invalid cast will trigger the <a class="el" href="a00886.html" title="Exception: An operation was invoked on an inappropriate object or at an inappropriate time.">dds::core::IllegalOperationError</a> exception. <pre class="fragment">  dds::domain::DomainParticipant dp(0);
  dds::pub::Publisher pub(dp);
  dds::core::Entity en(pub);       /* Up-cast */

  dds::pub::Publisher pub1(en);    /* Down-cast by constructor. */
  dds::pub::Publisher pub2(dds::core::null);
  pub2 = en;                       /* Down-cast by assignment.  */

  dds::sub::Subscriber sub1(en);   /* This throws an exception (can not cast pub to sub). */
  dds::sub::Subscriber sub2(dds::core::null);
  sub2 = en;                       /* This throws an exception (can not cast pub to sub). */
</pre></li>
<li>During the conversions, new temporary objects (aka rvalues) are created. This has some restrictions because you can't assign a rvalue to an non-const reference: <pre class="fragment">  using dds::core::cond;

  void func(GuardCondition  gc) { }
  void func_ref(GuardCondition&amp; gc) { }
  void func_cref(const GuardCondition&amp; gc) { }

  /* GuardCondition &lt;-&gt; Condition conversion is used to illustrate the restriction,
  * but this principle is applicable for all conversions. */
  GuardCondition gc1;

  Condition cond(gc1);                 /* rvalue assigned to lvalue immediately:  OK            */
  GuardCondition gc2(cond);            /* rvalue assigned to lvalue immediately:  OK            */
  const GuardCondition &amp;gc3(cond);     /* rvalue assigned to const reference:     OK            */
  GuardCondition &amp;gc4(cond);           /* rvalue assigned to non-const reference: Compile Error */

  func(cond);        /* rvalue assigned to lvalue function argument immediately:  OK            */
  func_cref(cond);   /* rvalue assigned to const reference function argument:     OK            */
  func_ref(cond);    /* rvalue assigned to non-const reference function argument: Compile Error */
  func_ref(gc1);                       /* no conversion, no rvalue to assign:     OK            */
</pre></li>
</ul>
</li>
<li>Some class hierarchies have changed.<ul>
<li>The AnyDataReader is now a parent class of DataReader&lt;T&gt;.</li>
<li>The AnyDataWriter is now a parent class of DataWriter&lt;T&gt;.</li>
<li>The AnyTopic is now a parent class of Topic&lt;T&gt;.<ul>
<li>The function <a class="el" href="a00265.html#afb7c4b2981147f4d183212c2561bddc3">get()</a> was used to convert an Any* entity into a typed entity. Now the conversion can be done by the new casting system. <pre class="fragment">  dds::sub::DataReader&lt;Foo::Bar&gt; reader(subscriber);
  dds::sub::AnyDataReader any(reader);        /* Up-cast   */
  dds::sub::DataReader&lt;Foo::Bar&gt; rdr1(any);   /* Down-cast */
  dds::sub::DataReader&lt;Foo::Qux&gt; rdr2(any);   /* Exception */
</pre></li>
</ul>
</li>
</ul>
</li>
<li>The TopicDescription class is now typeless.<ul>
<li>Because the TopicDescription is typeless, it replaces the AnyTopicDescription functionality. AnyTopicDescription is therefore deleted.</li>
</ul>
</li>
<li>The Query and QueryCondition classes have some changes.<ul>
<li>The QueryCondition now inherits from Query. This enables the use of the QueryCondition as a content filter which can be applied to a Selector associated with a DataReader.</li>
<li>The Query inherits from Reference instead of Value. This implies that the copy semantics have changed (shallow copy instead of deep copy). This affects the behavior of the Query when used as content filter of a DataReader::Selector. When a query is applied to a Selector and for example the Query parameters are changed then these changes will also be applied to the associated Selector.</li>
<li>Currently the state of the Query may change when the Query is used with a Selector and on this Selector a state filter is applied. In that case the state filter applied on the Selector will also be applied to the associated Query. This does not apply when a QueryCondition is used as a content filter of a Selector. Thus the setting of the Selector's state filter will not affect the state of the QueryCondition associated with that Selector.</li>
</ul>
</li>
<li>The Functors that you may apply to the Condition class no longer expect typeless operations.<ul>
<li>Each functor operation now expects 1 parameter of type dds:core::cond::Condition&amp;.</li>
<li>You can also specify functor operations that expect a parameter of a subclass of Condition (e.g. const <a class="el" href="a01234.html" title="ReadCondition objects are conditions specifically dedicated to read operations and attached to one Da...">dds::sub::cond::ReadCondition</a>&amp;).<ul>
<li>In that case one of the above-mentioned implicit upcast constructors will be invoked.</li>
<li>If the functor operation that you specify expects a certain subclass of Condition that does not match the type of Condition that is passed, an IllegalOperationError will be thrown.</li>
</ul>
</li>
<li>When using a subclass as functor parameter, an implicit conversion needs to happen. This means that the parameter of the functor has the same restrictions as mentioned in the Conversions paragraph: a functor with a non-const subclass reference will not compile. The GuardCondition subclass is used as example, but the restriction is applicable for all Condition subclasses. <pre class="fragment">  /*
  * Compilable GuardCondition functors
  */
  class FunctorGuardConditionConst {
  public:
      void operator ()(const dds::core::cond::GuardCondition&amp; condition) {
          /* condition not modifiable */
      }
  };
  class FunctorGuardConditionNonConst {
  public:
      void operator ()(dds::core::cond::GuardCondition condition) {
          /* condition modifiable (not a reference) */
      }
  };
  class FunctorCondition {
  public:
      void operator ()(dds::core::cond::Condition&amp; condition) {
          /* Notice the non-const Condition reference.
          * This doesn't need a conversion, so no rvalue is created.
          * The cast has to be done explicitly, when needed. */
      }
  };

  /*
  * NOT Compilable GuardCondition functor
  */
  class FunctorGuardConditionFail {
  public:
      void operator ()(dds::core::cond::GuardCondition&amp; condition) {
          /* Notice the non-const GuardCondition reference... */
      }
  };
</pre></li>
</ul>
</li>
<li>The StatusCondition is now a singleton.<ul>
<li>That means that if I instantiate multiple StatusConditions for the same Entity, they will all refer to the same StatusCondition.</li>
<li>This allows for patterns where I can create a StatusCondition, pass a functor to it, and then create another reference to the StatusCondition based on an AnyReader that is typeless. Since both StatusConditions originate from the same Entity, they will both share the same functor.<ul>
<li>This, and the fact that functors now always receive the Condition that has triggered, allows for a nice way to dispatch to the functors you prepared for your typed Readers: see the code block below. <pre class="fragment">  // Create participant and coherent Subscriber.
  dds::domain::DomainParticipant dp(0);
  dds::sub::qos::SubscriberQos subQos = dp.default_subscriber_qos();
  subQos &lt;&lt; dds::core::policy::Presentation::GroupAccessScope(true, false); // coherent = true, ordered = false.
  dds::sub::Subscriber mySub(dp, subQos);
  dds::core::cond::WaitSet myWS();

  // Create the topics
  dds::topic::Topic&lt;Space::Type1&gt; myTopic1(dp, "Topic1");
  dds::topic::Topic&lt;Space::Type2&gt; myTopic2(dp, "Topic2");
  ....

  // Create unique functors for each topic.
  class Reader1SCFunctor {
  public:
      void operator ()(const dds::core::cond::StatusCondition &amp;cond) {
          dds::sub::DataReader&lt;Space::Type1&gt; dr(cond.entity());
          dds::sub::LoanedSamples&lt;Space::Type1&gt; samples = dr.take();
      }
  }
  ....

  // Create the Readers and pass a unique Functor to their StatusConditions.
  dds::sub::DataReader&lt;Space::Type1&gt; reader1(sub, myTopic1);
  dds::core::cond::StatusCondition statusCond1(reader1, myReader1SCFunctor);
  myWS.attach_condition(statusCond1);
  dds::sub::DataReader&lt;Space::Type1&gt; reader2(sub, myTopic2);
  dds::core::cond::StatusCondition statusCond2(reader2, myReaderSC2Functor);
  myWS.attach_condition(statusCond2);
  ...

  while (true)
  {
      std::vector&lt;dds::sub::AnyDataReader&gt; readerList;
      dds::sub::status::DataState notReadState(dds::sub::status::SampleState::not_read());

      myWS.wait(dds::core::Duration::infinite());

      dds::sub::CoherentAccess coherentScope(mySub);
      uint32_t nrReaders = dds::sub::find&lt;dds::sub::AnyDataReader&gt;(
                      mySub, notReadState, std::back_inserter&lt;std::vector&lt;dds::sub::AnyDataReader&gt; &gt;(readerList), MAX_READERS);
      for (uint32_t i = 0; i &lt; nrReaders; i++) {
          dds::core::cond::StatusCondition sc(readerList[i]);
          sc.dispatch();
      }
      coherentScope.end(); // Moved into the while loop. Can be removed too, since the destructor will otherwise end the set.
  }
</pre></li>
</ul>
</li>
</ul>
</li>
<li><p class="startli">The following function </p><pre class="fragment">  template &lt;typename ANYTOPIC, typename BinIterator&gt;dds::topic::discover(const dds::domain::DomainParticipant&amp; dp, BinIterator begin);
</pre><p class="startli">has been renamed to </p><pre class="fragment">template &lt;typename ANYTOPIC, typename BinIterator&gt;dds::topic::discover_all(const dds::domain::DomainParticipant&amp; dp, BinIterator begin)
</pre><p class="startli">Reason for this is that the old name clashed with </p><pre class="fragment">template &lt;typename TOPIC&gt;
TOPIC discover(const dds::domain::DomainParticipant&amp; dp,
            const std::string&amp; name,
            const dds::core::Duration&amp; timeout = dds::core::Duration::infinite());
</pre><p class="startli">when invoked with just 2 parameters. Instead of substituting the 3rd parameter, the compiler would in that case interpret the std::string as the BinIterator and invoke that function instead.</p>
</li>
<li>This is because overloaded functions are first matched on the amount of parameters, and only when there is no match it will look for possibilities to add default parameters. In this particular case a match with 2 parameters is possible by using std::string as the template parameter for the BinIterator. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.16 </li>
  </ul>
</div>
</body>
</html>
